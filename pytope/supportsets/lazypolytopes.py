import numpy as np

from scipy.optimize import linprog

class LazyVertexSet():
    # Set to allow matrix multiplication with numpy arrays
    __array_ufunc__ = None

    def __init__(self, V: np.ndarray):
        assert len(V.shape) < 3, \
            'Vertices must be a numpy array or list (2-d numpy array where ' \
            'each row is a vertex.'
        
        if len(V.shape) == 1:
            V = np.atleast_2d(V)

        self._V = V

    @property
    def V(self):
        return self._V
    
    @property
    def nv(self):
        return self.V.shape[0]

    @property
    def dim(self):
        return self.V.shape[1]

    @property
    def bbox(self):
        return np.vstack((np.min(self.V, axis=0), np.max(self.V, axis=0)))

    def __getitem__(self, inds):
        return self.V[inds]

    def sample_vertex(self):
        return self.V[np.random.randint(self.nv)]

    def __rmatmul__(self, M: np.ndarray):
        return LazyVertexSet(self.V @ M.T)

    def contains(self, x: np.ndarray, method='interior-point', callback=None,
        options=None, x0=None):
        assert len(x.shape) < 3, 'Point(s) to check containment must be an ' \
            'array or 2-d numpy array for which each row is an array.'

        if len(x.shape) == 2:
            return np.array([self.contains(v) for v in x])

        res = linprog(np.zeros(self.nv), 
            A_eq=np.vstack((np.ones(self.nv), self.V.T)),
            b_eq=np.concatenate(([1], x)),
            bounds=(0, 1), 
            method=method, callback=callback, options=options, x0=x0)

        return res.success

    def __len__(self):
        return self.V.shape[0]

class LazyFacetSet():
    pass

class ConvexVertexSampler():
''' ConvexVertexSampler

The convex vertex sampling method is a hueristic to provide faster sampling of 
the interior of a LazyVertexSet. Traditional rejection sampling for sets with
large number of vertices can become computationally expensive as checking if 
a point, x, is contained in the VertexSet, V, can be costly (even as a linear
program).

Convex vertex sampling generates efficient sampling by utilizing the notion
of convexity. Specifically, the sampler is initializes a point, x, to a random
vertex of the set V. Then each sample is generated by:

    lam <- Uniform([0, 1])
    x   <- lam * x + (1 - lam) * RandomVertex(V)

This provides samples very quickly. However, unlike rejection sampling, the
distribution of samples is not uniform. The distribution is instead related to 
the concentration of vertices.

INPUTS:
    S   LazyVertexSet
'''
    def __init__(self, S: LazyVertexSet):
        self._S = S
        self._x = S.sample_vertex()

    def sample(self):
        lam = np.random.rand()

        self._x = lam * self._x + (1 - lam) * self._S.sample_vertex()

        return self._x
